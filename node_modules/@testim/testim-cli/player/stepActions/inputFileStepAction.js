'use strict';

const StepAction = require('./stepAction');
const Promise = require('bluebird');
const _ = require('lodash');
const logger = require('../../commons/logger').getLogger('input-file-step-action');
const { codeSnippets, utils } = require('../../commons/getSessionPlayerRequire');
const { extractElementId } = require('../../utils');
const inputFileUtils = require('../../inputFileUtils');
const featureFlagService = require('../../commons/featureFlags');

class InputFileStepAction extends StepAction {
    uploadFile(localFileLocation) {
        return this.driver.uploadFile(localFileLocation);
    }

    forceInputToBeVisible(target, visibleScriptOptions) {
        logger.info('workaround - stepaction - move element to visible position');

        const getVisibleElementCode = `
            var getLocatedElement = ${codeSnippets.getLocatedElementCode};
            var getVisibleElement = ${inputFileUtils.getVisibleElementScript(visibleScriptOptions)};
            return getVisibleElement.apply(null, arguments);
        `;

        return this.driver.executeJS(getVisibleElementCode, target.locatedElement);
    }

    safariPreUploadActions(target) {
        const options = {
            width: '150px',
            height: '150px',
            left: '10px',
            top: '10px',
        };
        return this.forceInputToBeVisible(target, options)
            .tapCatch(err => logger.error('failed to set input file in Safari recovery', { err }));
    }

    uploadFilesAndForceVisibility(gridLocalFiles, target) {
        const preUploadStep = this.driver.isSafari() ?
            //     // in safari we force the visibility ahead of time because making it visible the second time around doesn't work
            this.safariPreUploadActions(target) :
            Promise.resolve();

        return preUploadStep.then(() => this.uploadFiles(gridLocalFiles, target))
            .catch(err => {
                const edgeErrorEditableMessage = 'The element is not editable';
                const edgeErrorFocusableMessage = 'The element is not focusable';
                const safariErrorVisibleMessege = 'An element command could not be completed because the element is not visible on the page.';
                const elementNotInteractable = 'element not interactable';
                const elementNotPointerOrKeyboardInteractable = 'element is not pointer- or keyboard interactable';
                const invalidStateMsg = 'invalid element state: Element is not currently interactable and may not be manipulated';
                const mustBeVisibleMsg = 'Element must not be hidden, disabled or read-only';
                const notReachableByKeyboard = 'is not reachable by keyboard';
                const errorMsg = err ? err.message : '';
                // Workaround move element if element is not visible or disabled
                if (_.isEqual(errorMsg, invalidStateMsg) ||
                    _.startsWith(errorMsg, mustBeVisibleMsg) ||
                    _.startsWith(errorMsg, edgeErrorEditableMessage) ||
                    _.startsWith(errorMsg, edgeErrorFocusableMessage) ||
                    _.startsWith(errorMsg, safariErrorVisibleMessege) ||
                    _.includes(errorMsg, notReachableByKeyboard) ||
                    _.includes(errorMsg, elementNotInteractable) ||
                    _.includes(errorMsg, elementNotPointerOrKeyboardInteractable)
                ) {
                    return this.forceInputToBeVisible(target).then(() => this.uploadFiles(gridLocalFiles, target));
                }

                logger.error('failed to set input file', { err });
                return Promise.reject(err);
            });
    }

    async uploadFiles(gridLocalFiles, target) {
        for (const file of gridLocalFiles) {
            await this.driver.elementIdValue(extractElementId(target.seleniumElement), file);
        }
    }

    performAction() {
        const target = this.context.data[this.step.targetId || 'targetId'];
        const overrideAzureStorageUrl = featureFlagService.flags.overrideAzureStorageUrl.isEnabled();
        //TODO remove if after release session player
        return (utils.addTokenToFileUrl ? utils.addTokenToFileUrl(
            this.context.project.id,
            this.step.fileUrls,
            this.stepActionUtils.testimServicesApi,
            overrideAzureStorageUrl,
            logger,
        ) : Promise.resolve(this.step.fileUrls)).then((fileUrls) => {
            const useJsInputCodeInSafari = featureFlagService.flags.useJsInputCodeInSafari.isEnabled();
            if (this.driver.isSafari() && (useJsInputCodeInSafari || fileUrls.length > 1)) {
                return this.driver.executeJSWithArray(`
                const getLocatedElement = ${codeSnippets.getLocatedElementCode};
                const downloadAndUploadFile = ${downloadAndUpload()};
                return downloadAndUploadFile.apply(null, arguments);`,
                [target.locatedElement, fileUrls])
                    .then(() => Promise.resolve());
            }

            return inputFileUtils.downloadFilesAndUploadToGrid(fileUrls, this.uploadFile.bind(this))
                .then(gridLocalFiles => this.uploadFilesAndForceVisibility(gridLocalFiles, target))
                .then(() => Promise.resolve());
        });
    }
}

module.exports = InputFileStepAction;
function downloadAndUpload() {
    return `async function downloadAndUpload(locatedElement, fileUrls) {
        const fileIsNative = typeof window.File === 'function' && (window.File.toString().indexOf('native code') > -1);
        const File = fileIsNative ? window.File : (function obtainSafeGlobals() {
            const attachTo  = document.body || document.documentElement;
            if (attachTo) {
                let tempIFrame;
                try {
                    tempIFrame = document.createElement('iframe');
                    tempIFrame.style.setProperty('display', 'none');
                    tempIFrame.style.setProperty('pointer-events', 'none');
                    attachTo.appendChild(tempIFrame);
                    const { File } = tempIFrame.contentWindow;
                    return File;
                } finally {
                    if (tempIFrame) {
                        tempIFrame.parentElement.remove(frame);
                    }
                }
            } else {
                return window.File;
            }
        })();
        const element = getLocatedElement(locatedElement);
        if(!element) {
            throw new Error('element not found');
        }

        const fileList = await Promise.all(fileUrls.map(async ({ url, name }) => {
            const blob = await fetch(url).then(r => r.blob());
            return new File([blob], name, { type: blob.type });
        }));

        fileList.item = function(ind) { return this[ind]; };
        let changeWasFired = false;
        const changeFiredHandler = (e) => {
            changeWasFired = true;
        };

        element.addEventListener("change", changeFiredHandler, true);
        Reflect.deleteProperty(element, 'files');
        Reflect.defineProperty(element, 'files', { get() { return fileList; }, configurable: true });
        await Promise.resolve(); // wait microtick
        element.dispatchEvent(new Event("input", { bubbles: true }));
        if (!changeWasFired) {
            element.dispatchEvent(new Event("change", { bubbles: true }));
        }
        element.removeEventListener("change", changeFiredHandler, true);
    }`;
}
