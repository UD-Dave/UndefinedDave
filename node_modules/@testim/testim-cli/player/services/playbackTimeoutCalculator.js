"use strict";
var COMMUNICATION_BUFFER_TIME = 1000;
const _ = require('lodash');
const logger = require('../../commons/logger').getLogger('playback-timeout-calculator');

let warnedAboutDebugger = false;

class PlaybackTimeoutCalculator {

    constructor(isDebuggerConnected) {
        this.resetStepVariables();
        this.resetRetryVariables();
        this.isDebuggerConnected = isDebuggerConnected;
    }

    resetStepVariables(totalStepTime, currentRetryTimes) {
        this.currentRetryTimes = currentRetryTimes || [];
        this.totalStepTime = totalStepTime || 0;
        this.totalStepTimesReport = [];
        this.currentRetryTimesReport = {};
        var now = Date.now();
        this.currentRetryStart = now;
        this.lastUpdateTime = now;
    }

    resetRetryVariables() {
        var now = Date.now();
        this.currentRetryStart = now;
        this.lastUpdateTime = now;
        this.totalStepTimesReport.push(this.currentRetryTimesReport);
        this.currentRetryTimesReport = {};
    }

    initStepRun(stepPlayback) {
        var getRetryTimeoutSuggestions = (totalStepTime) => {
            const timeToPlayStep = this.getTotalStepTimeLeftToPlay(stepPlayback, totalStepTime);
            const MINIMAL_RETRY_TIME = 5000;
            if (timeToPlayStep <= MINIMAL_RETRY_TIME) {
                return [MINIMAL_RETRY_TIME];
            }
            return [Math.max(MINIMAL_RETRY_TIME, timeToPlayStep / 3)];
        };
        stepPlayback.setStartTimestamp();
        const totalStepTime = this.getTotalStepRunTime(stepPlayback);
        var currentRetryTimes = ["simple-ui-verification", "wait-for-simple-ui-verification", "custom-validation"].includes(stepPlayback.stepType) ? [totalStepTime] : getRetryTimeoutSuggestions(totalStepTime);
        this.resetStepVariables(totalStepTime, currentRetryTimes);
        stepPlayback.context.data.maxTotalStepTime = totalStepTime;
    }

    getStepTimes() {
        this.totalStepTimesReport.push(this.currentRetryTimesReport);
        return _.cloneDeep(this.totalStepTimesReport);
    }

    initRetryTime() {
        this.resetRetryVariables();
    }

    getTotalStepRunTime(stepPlayback) {
        return (stepPlayback.step.useStepTimeout && stepPlayback.step.stepTimeout) ?
            stepPlayback.step.stepTimeout :
            stepPlayback.context.config.stepTimeout;
    }
    getTotalStepTimeLeftToPlay(stepPlayback, totalStepTime = this.totalStepTime) {
        const playTimeSoFar = Date.now() - stepPlayback.startTimestamp;
        return totalStepTime - playTimeSoFar;
    }
    getCurrentRetryTime(stepPlayback) {
        return (stepPlayback.retryIndex < this.currentRetryTimes.length) ?
            this.currentRetryTimes[stepPlayback.retryIndex] :
            this.getTotalStepTimeLeftToPlay(stepPlayback);
    }
    getTotalCurrentRetryTimeLeft(stepPlayback) {
        var totalRetryTime = Date.now() - this.currentRetryStart;
        return this.getCurrentRetryTime(stepPlayback) - totalRetryTime + COMMUNICATION_BUFFER_TIME;
    }
    getTabTimeout(stepPlayback) {
        return this.getTotalCurrentRetryTimeLeft(stepPlayback);
    }
    getDynamicParentTimeout(stepPlayback) {
        return this.getTotalCurrentRetryTimeLeft(stepPlayback);
    }
    getFrameTimeout(stepPlayback) {
        return this.getTotalCurrentRetryTimeLeft(stepPlayback);
    }
    getLocateTimeout(stepPlayback) {
        return this.getTotalCurrentRetryTimeLeft(stepPlayback);
    }

    calcAndroidScrollTimeout(stepPlayback) {
        const buffer = 5000;
        let timePerEvent = 2000; // absolute scroll - 2 seconds per event + buffer

        if (stepPlayback.step.isScrollToElement) {
            // scroll to element, 4 secs per event to account for locate flow in each event
            timePerEvent = 4000;
        }

        return (stepPlayback.step.events.length * timePerEvent) + buffer;

    }

    getActionTimeout(stepPlayback) {
        if (this.isDebuggerConnected) {
            return 6e5;
        }
        const SLEEP_ERROR_MARGIN_MS = 5000;
        const actionType = stepPlayback.step.type;
        const MIN_ACTION_PLAYBACK_TIME = 30000;

        var actionTime;
        if (actionType === "sleep") {
            actionTime = stepPlayback.step.durationMS + SLEEP_ERROR_MARGIN_MS;
        } else if (actionType === "android-scroll") {
            actionTime = Math.max(this.calcAndroidScrollTimeout(stepPlayback), MIN_ACTION_PLAYBACK_TIME);
        } else {
            actionTime = Math.max(this.getTotalStepTimeLeftToPlay(stepPlayback), MIN_ACTION_PLAYBACK_TIME);
        }
        return actionTime;
    }

    setStepPhaseTime(phase) {
        var now = Date.now();
        var totalTime = now - this.lastUpdateTime;
        this.lastUpdateTime = now;
        this.currentRetryTimesReport[phase] = totalTime;
    }

    reportGetTabTime() {
        this.setStepPhaseTime("tab");
    }

    reportGetFrameTime() {
        this.setStepPhaseTime("frame");
    }

    reportCalcConditionTime() {
        this.setStepPhaseTime("condition");
    }

    reportPreLocateActionsTime() {
        this.setStepPhaseTime("pre-locate");
    }

    reportFindElementsTime() {
        this.setStepPhaseTime("locate");
    }

    reportStepActionTime() {
        this.setStepPhaseTime("action");
    }
}


module.exports = PlaybackTimeoutCalculator;
