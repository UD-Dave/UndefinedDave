const { expect, sinon } = require('../../test/utils/testUtils');
const LambdatestService = require('../services/lambdatestService');
const testimNgrok = require('./testimNgrok');
const testimTunnel = require('./testimTunnel');

describe('testimTunnel', () => {
    describe('connect', () => {
        let ltConnectStub;
        let ngrokConnectStub;
        beforeEach(() => {
            ltConnectStub = sinon.stub(LambdatestService, 'connectTunnel').resolves();
            ngrokConnectStub = sinon.stub(testimNgrok, 'connectTunnel').resolves();
        });
        afterEach(() => {
            ltConnectStub.restore();
            ngrokConnectStub.restore();
        });

        it('should not connect to tunnel if tunnel option off', async () => {
            await testimTunnel.connect({});
            sinon.assert.notCalled(ltConnectStub);
            sinon.assert.notCalled(ngrokConnectStub);
        });

        it('should choose ngrok if passed grid is not a lambdatest grid', async () => {
            await testimTunnel.connect({ tunnel: true, gridData: { } });
            sinon.assert.notCalled(ltConnectStub);
            sinon.assert.calledOnce(ngrokConnectStub);
        });

        it('should choose lambdatest if passed grid is a lambdatest grid', async () => {
            await testimTunnel.connect({ tunnel: true, gridData: { type: 'testimLambdaTest' } });
            sinon.assert.calledOnce(ltConnectStub);
            sinon.assert.notCalled(ngrokConnectStub);
        });

        it('should choose lambdatest if passed grid is a hybrid grid', async () => {
            await testimTunnel.connect({ tunnel: true, gridData: { type: 'testimHybrid' } });
            sinon.assert.calledOnce(ltConnectStub);
            sinon.assert.notCalled(ngrokConnectStub);
        });

        it('should choose ngrok if passed grid is a hybrid grid and it is set to use ngrok tunnel', async () => {
            await testimTunnel.connect({ tunnel: true, gridData: { type: 'testimHybrid', tunnel: 'ngrok' } });
            sinon.assert.notCalled(ltConnectStub);
            sinon.assert.calledOnce(ngrokConnectStub);
        });

        it('should handle connect errors', async () => {
            ltConnectStub.rejects('error');
            await expect(testimTunnel.connect({ tunnel: true, gridData: { type: 'testimLambdaTest' } })).to.be.rejectedWith('Failed to start tunnel. Please contact support@testim.io');
        });
    });

    describe('disconnect', () => {
        let ltDisconnectStub;
        let ngrokDisconnectStub;
        beforeEach(() => {
            ltDisconnectStub = sinon.stub(LambdatestService, 'disconnectTunnel').resolves();
            ngrokDisconnectStub = sinon.stub(testimNgrok, 'disconnectTunnel').resolves();
        });
        afterEach(() => {
            ltDisconnectStub.restore();
            ngrokDisconnectStub.restore();
        });

        it('should not disconnect from tunnel if tunnel option off', async () => {
            await testimTunnel.disconnect({});
            sinon.assert.notCalled(ltDisconnectStub);
            sinon.assert.notCalled(ngrokDisconnectStub);
        });

        it('should choose ngrok if passed grid is not a lambdatest grid', async () => {
            await testimTunnel.disconnect({ tunnel: true, gridData: { } });
            sinon.assert.notCalled(ltDisconnectStub);
            sinon.assert.calledOnce(ngrokDisconnectStub);
        });

        it('should choose lambdatest if passed grid is a lambdatest grid', async () => {
            await testimTunnel.disconnect({ tunnel: true, gridData: { type: 'testimLambdaTest' } });
            sinon.assert.calledOnce(ltDisconnectStub);
            sinon.assert.notCalled(ngrokDisconnectStub);
        });

        it('should choose lambdatest if passed grid is a hybrid grid', async () => {
            await testimTunnel.disconnect({ tunnel: true, gridData: { type: 'testimHybrid' } });
            sinon.assert.calledOnce(ltDisconnectStub);
            sinon.assert.notCalled(ngrokDisconnectStub);
        });

        it('should choose ngrok if passed grid is a hybrid grid and it is set to use ngrok tunnel', async () => {
            await testimTunnel.disconnect({ tunnel: true, gridData: { type: 'testimHybrid', tunnel: 'ngrok' } });
            sinon.assert.notCalled(ltDisconnectStub);
            sinon.assert.calledOnce(ngrokDisconnectStub);
        });

        it('should handle connect errors', async () => {
            ltDisconnectStub.rejects('error');
            await expect(testimTunnel.disconnect({ tunnel: true, gridData: { type: 'testimLambdaTest' } })).to.be.rejectedWith('catch error - failed to close tunnel');
        });
    });
});
