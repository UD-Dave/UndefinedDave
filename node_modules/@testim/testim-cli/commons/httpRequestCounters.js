'use strit';

const { sum } = require('lodash');
const { method } = require('bluebird');
// we remove entries after 15 minutes, note that this isn't accurate because
// we remove the "fail"/"success" 10 minutes after we add them (and not the "call")
// this is fine since these values are an estimation and not an accurate representation
// we poll them when a test fails - so values older than 15 minutes (10 minutes is
// the default timeout) are hardly relevant.
const ttl = 60 * 1000 * 15;

module.exports.makeCounters = () => {
    const counters = {
        call: new Map(),
        success: new Map(),
        fail: new Map(),
    };
    function update(counter, key) {
        const result = counter.get(key) || 0;
        counter.set(key, result + 1);
        setTimeout(() => {
            const result = counter.get(key) || 1;
            counter.set(key, result - 1);
        }, ttl);
    }
    function wrapWithMonitoring(fn, name = fn.name) {
        return method(async function (...args) {
            update(counters.call, name);
            try {
                const result = await fn.call(this, ...args);
                update(counters.success, name);
                return result;
            } catch (e) {
                update(counters.fail, name);
                throw e;
            }
        });
    }
    wrapWithMonitoring.isNetworkHealthy = function isNetworkHealthy() {
        const allFailed = sum([...counters.fail.values()]);
        const allSuccess = sum([...counters.success.values()]);
        const allCalls = sum([...counters.call.values()]);
        // we declare a test unhealthy network wise if
        // 1. more than 10 requests failed and there are fewer than 100 requests
        // 2. more than 10% of requests (out of finished requests) failed
        // note that the network can be unhealthy but the test would still pass
        if (allCalls < 100) {
            return allFailed < 10;
        }
        return (allSuccess + allFailed) > allFailed * 10;
    };
    wrapWithMonitoring.counters = counters; // expose the counters used to the outside
    wrapWithMonitoring.isNetworkHealthy.counters = wrapWithMonitoring.counters;
    return wrapWithMonitoring;
};
