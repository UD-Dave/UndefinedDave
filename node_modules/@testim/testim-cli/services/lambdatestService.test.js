const { expect, sinon } = require('../../test/utils/testUtils');
const servicesApi = require('../commons/testimServicesApi');
const LambdatestService = require('./lambdatestService');

describe('LambdatestService', () => {
    let lambdatestService;
    beforeEach(() => {
        lambdatestService = new LambdatestService();
    });

    describe('isLambdatestGrid', () => {
        it('should consider a lambda test grid as a lambda test grid', () => {
            expect(LambdatestService.isLambdatestGrid({ type: 'testimLambdaTest' })).to.be.true;
        });
        it('should consider a hybrid grid as a lambda test grid according to ist provider', () => {
            expect(LambdatestService.isLambdatestGrid({ type: 'testimHybrid', provider: 'lambdatest' })).to.be.true;
            expect(LambdatestService.isLambdatestGrid({ type: 'testimHybrid', provider: 'other' })).to.be.false;
        });
    });

    describe('isLambdatestRun', () => {
        it('should consider a lambda test run as a lambda test run', () => {
            lambdatestService.isActive = true;
            expect(lambdatestService.isLambdatestRun()).to.be.true;
        });

        it('should consider non lambda test run as non lambda test run', () => {
            lambdatestService.isActive = false;
            expect(lambdatestService.isLambdatestRun()).to.be.false;
        });
    });

    describe('enableIfNeeded', () => {
        let fetchLambdatestConfigStub;
        beforeEach(() => {
            fetchLambdatestConfigStub = sinon.stub(servicesApi, 'fetchLambdatestConfig').resolves({});
        });
        afterEach(() => {
            fetchLambdatestConfigStub.restore();
            delete LambdatestService.lambdatestConfigPromise;
            delete LambdatestService.lambdatestConfig;
        });

        it('should not enable lambdatest for non lt grid', async () => {
            await lambdatestService.enableIfNeeded({});
            expect(lambdatestService.isActive).to.be.false;
            sinon.assert.notCalled(fetchLambdatestConfigStub);
        });

        it('should enable lambdatest for lt grid', async () => {
            await lambdatestService.enableIfNeeded({ type: 'testimLambdaTest' });
            expect(lambdatestService.isActive).to.be.true;
            sinon.assert.calledOnce(fetchLambdatestConfigStub);
        });

        it('should enable lambdatest for hybrid grid with lt provider', async () => {
            await lambdatestService.enableIfNeeded({ type: 'testimHybrid', provider: 'lambdatest' });
            expect(lambdatestService.isActive).to.be.true;
            sinon.assert.calledOnce(fetchLambdatestConfigStub);
        });

        it('should not enable lambdatest for hybrid grid with other provider', async () => {
            await lambdatestService.enableIfNeeded({ type: 'testimHybrid', provider: 'other' });
            expect(lambdatestService.isActive).to.be.false;
            sinon.assert.notCalled(fetchLambdatestConfigStub);
        });

        it('should cache lambdatest config', async () => {
            await lambdatestService.enableIfNeeded({ type: 'testimLambdaTest' });
            await lambdatestService.enableIfNeeded({ type: 'testimLambdaTest' });
            sinon.assert.calledOnce(fetchLambdatestConfigStub);
        });
    });

    describe('specific lt capabilities', () => {
        it('should return lt session timeout for lt grid', async () => {
            lambdatestService.isActive = true;
            expect(lambdatestService.getSessionTimeout).to.be.equal(900000);
            lambdatestService.isActive = false;
            expect(lambdatestService.getSessionTimeout).to.be.equal(null);
        });

        it('should return lt session retries for lt grid', async () => {
            lambdatestService.isActive = true;
            expect(lambdatestService.getSessionRetries).to.be.equal(1);
            lambdatestService.isActive = false;
            expect(lambdatestService.getSessionRetries).to.be.equal(null);
        });
    });

    describe('connectTunnel', () => {
    });
});
